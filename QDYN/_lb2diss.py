"""Conversion script between Lindblad operators and a dissipation
superoperator"""

import sys
import os
import logging
import shutil
from collections import OrderedDict

import click
from click import echo

from . import __version__
from .config import read_config_fh, write_config, config_data_to_str
from .io import read_indexed_matrix, write_indexed_matrix
from .dissipation import lindblad_ops_to_dissipator


class CannotConvertConfigError(ValueError):
    """Exception to be raised if the config does not meet the prerequisites for
    conversion"""
    pass


def get_ham_dimension(config_data, label):
    """Determin the Hilbert space dimension from the 'n_surf' field of the
    'ham' entry in config data with matching label"""
    for line_data in config_data.get('ham', []):
        if line_data.get('label', '') == label:
            if 'n_surf' in line_data:
                return int(line_data['n_surf'])
    return 0


def dissipator_unit(lindblad_unit):
    """Choose a dissipator unit based on the unit of the Lindblad operators"""
    if lindblad_unit.startswith('sqrt_'):
        return lindblad_unit.replace('sqrt_', '')
    elif lindblad_unit in ['iu', 'au', 'unitless', 'dimensionless']:
        return lindblad_unit
    else:
        raise CannotConvertConfigError(
            "Cannot convert from unit '%s'" % lindblad_unit)


def convert(
        runfolder, config_data, label, hs_dimension, delete_lindblad_files,
        dissipator_filename):
    """"Convert Lindblad operators with `label` to a dissipator in the given
    `config_data`, return modified copy of `config_data`

    Delete Lindblad data files in `runfolder` (if `delete_lindblad_files` is
    True) and write dissipator data to `dissipator_filename` inside
    `runfolder`. The Lindblad operators must be have a Hilbert space dimension
    of `hs_dimension`
    """
    logger = logging.getLogger(__name__)
    config_data = config_data.copy()
    lindblad_ops = []
    lindblad_unit = None
    processed = []
    for i_line, lindblad_data in enumerate(config_data.get('dissipator', [])):
        if lindblad_data.get('type', '') != 'lindblad_ops':
            raise CannotConvertConfigError(
                "All entries in the 'dissipator' section in config with label "
                "'%s' must have 'type = lindblad_ops'" % label)
        if label != lindblad_data.get('label', ''):
            continue  # skip labels we are not interested in
        filename = os.path.join(runfolder, lindblad_data.get('filename', ''))
        L = read_indexed_matrix(filename, shape=(hs_dimension, hs_dimension))
        if delete_lindblad_files:
            logger.debug("Removing file %s", filename)
            os.unlink(os.path.join(runfolder, filename))
        processed.append(i_line)
        lindblad_ops.append(L)
        if lindblad_unit is None:
            lindblad_unit = lindblad_data.get('op_unit', 'iu')
        else:
            if lindblad_unit != lindblad_data.get('op_unit', 'iu'):
                raise CannotConvertConfigError(
                    "All entries in the 'dissipator' section in config with "
                    "the label %s must have the same op_unit"
                    % label)
        if lindblad_data.get('pulse', 0) != 0:
            raise CannotConvertConfigError(
                "Cannot process Lindblad operators that are connected to "
                "pulses")
    if len(processed) == 0:
        raise CannotConvertConfigError(
            "config does not contain any Lindblad operators for label '%s'"
            % label)
    for i_line in processed[::-1]:
        logger.debug("Remove line %d from section 'lindblad_ops' of config",
                     (i_line + 1))
        del config_data['dissipator'][i_line]
    unit = dissipator_unit(lindblad_unit)
    logger.debug("Use dissipator unit %s", unit)
    D = lindblad_ops_to_dissipator(lindblad_ops)
    comment = 'Dissipator [%s] generated by qdyn_lb2diss' % unit
    filename = os.path.join(runfolder, dissipator_filename)
    logger.debug("writing dissipator to %s", filename)
    write_indexed_matrix(D, filename, comment, limit=1e-14)
    dissipator_data = OrderedDict([
        ('type', 'dissipator'), ('label', label),
        ('filename', dissipator_filename), ('op_unit', unit),
        ('sparsity_model', 'indexed')])
    config_data['dissipator'].append(dissipator_data)
    return config_data


@click.command()
@click.help_option('--help', '-h')
@click.version_option(version=__version__)
@click.option('--debug', is_flag=True,
    help='enable debug logging')
@click.option('--label', metavar='LABEL', default='',
    help='The label for which to convert the Lindblad operators')
@click.option('--overwrite', is_flag=True,
    help='Overwrite CONFIG file. Otherwise, new config file is written to '
    'STDOUT')
@click.option('--bak', type=str, metavar='BAK', default='~',
    help="In conjunction with --overwrite, filename "
    "postfix for copy of the original config file. Defaults to '~'. "
    "Use --no-bak to not keep a backup.")
@click.option('--no-bak', is_flag=True,
    help="Do not keep a backup of the input CONFIG files.")
@click.option('--dim', type=int, metavar='DIM', default=0,
    help="Dimension of the Hilbert space (inte). If not given, determine from "
    "'nsurf' flag in 'ham' section of CONFIG.")
@click.option('--delete', is_flag=True,
    help='delete data files for converted Lindblad operators')
@click.option('--dissfile', metavar='DISSFILE',
    help="Output file for dissipator, to be written "
    "to the same folder as CONFIG (or the current working directory if "
    "reading from STDIN). Defaults to 'D_<LABEL>.dat'")
@click.argument('config', type=click.File('r'))
def main(debug, label, overwrite, bak, no_bak, dim, delete, dissfile, config):
    """Convert Lindblad operators in CONFIG to a a dissipator.

    Read the CONFIG file, identify all Lindblad operators with the given
    LABEL, and write/print a new config file where these Lindblad operators
    have been replaced by a singles dissipation superoperator. In the new
    config file, the entry for this dissipator will reference DISSFILE,
    relative to CONFIG itself.

    CONFIG may be '-' to read from STDIN. In this case, DISSFILE is written to
    the current working directory, and any data referenced from the config data
    is also relative to the current working directory.

    By default, the updated config file is written to STDOUT. You may instead
    overwrite CONFIG with the updated data. A backup of the original CONFIG is
    kept with postfix BAK unless --no-bak is given. The data files for the
    original Lindblad operators may be deleted by specifying --delete.
    """
    logging.basicConfig(level=logging.WARNING)
    logger = logging.getLogger(__name__)
    if debug:
        logger.setLevel(logging.DEBUG)
        logger.debug("Enabled debug output")
    try:
        config_name = config.name
        if config_name == '<stdin>':
            logger.debug("Reading from stdin")
            runfolder = '.'
            if overwrite:
                echo("Cannot use --overwrite when reading from stdin",
                     err=True)
                sys.exit(1)
        else:
            runfolder = os.path.split(config_name)[0]
        config_data = read_config_fh(config)
        if dim < 1:
            dim = get_ham_dimension(config_data, label)
        if dim < 1:
            raise CannotConvertConfigError(
                "Cannot determine Hilbert space dimension from config")
        if dissfile is None:
            if label == '':
                dissfile = 'D.dat'
            else:
                dissfile = 'D_%s.dat' % label
        out_data = convert(
            runfolder, config_data, label, dim, delete, dissfile)
        if overwrite:
            config.close()
            if no_bak:
                logger.debug("overwriting %s without backup", config_name)
            else:
                logger.debug("overwriting %s, with backup in %s",
                             config_name, config_name+bak)
                shutil.copy(config_name, config_name + bak)
            write_config(out_data, config_name)
        else:
            echo(config_data_to_str(out_data))
    except (CannotConvertConfigError, OSError) as exc_info:
        echo("ERROR: " + str(exc_info), err=True)
        sys.exit(1)
